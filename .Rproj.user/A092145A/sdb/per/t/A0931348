{
    "collab_server" : "",
    "contents" : "#' @return A JSON of every quote in the database, with quote, author, category, character count\n#* @get /all\nquote_all <- function() {\n  #connect to database\n  library(RSQLite)\n  db <- dbConnect(SQLite(), \"Auto_Generation.db\")\n  \n  #verify connection\n  if (dbIsValid(db) & dbExistsTable(db, \"Content\")) {\n    \n    #grab entire table \n    content <- dbReadTable(db, \"Content\")\n    \n    if (nrow(content) == 0) {\n      warning(\"There was not any content in the table.\")\n    }\n    \n    #convert to JSON \n    library(jsonlite)\n    output <- toJSON(content)\n  } else {\n    stop(\"Error connecting to the database.\")\n  }\n  \n  return(output)\n}\n\n\n\n\n#' @param search_term A string representing the term to be searched for.\n#' @parm char_count An optional integer input parameter representing the max character count. If not included, the default is set at 300. \n#' @return A JSON of every quote related to that search term, with quote, author, category, character count. The keyword can be matched in the content's text, quthor, or category.\n#* @get /search\nquote_search <- function(search_term, char_count = 300) {\n  #clean input \n  library(magrittr)\n  library(stringr)\n  library(SnowballC)\n  library(RSQLite)\n  search_term <- search_term %>% str_to_lower() %>% str_trim() %>% wordStem()\n  \n  #connect to database\n  db <- dbConnect(SQLite(), \"Auto_Generation.db\")\n  \n  #verify connection\n  if (dbIsValid(db) & dbExistsTable(db, \"Content\")) {\n    \n    #query table for input category\n    content <- dbGetQuery(db, paste(\"SELECT * FROM Content WHERE Text LIKE \\'%\", search_term, \"%\\'AND Char_Count <\",char_count, \n                                    \" OR Author LIKE \\'%\", search_term, \"%\\'AND Char_Count <\",char_count, \n                                    \" OR Category LIKE \\'%\", search_term, \"%\\'AND Char_Count <\",char_count,\";\", sep =\"\"))\n    \n    if (nrow(content) == 0) {\n      warning(\"There was not any content containing that search term.\")\n    }\n    \n    #convert to JSON \n    library(jsonlite)\n    output <- toJSON(content)\n  } else {\n    stop(\"Error connecting to the database.\")\n  }\n  \n  print('hi')\n  dbGetQuery(db, paste(\"SELECT * FROM Content WHERE Text LIKE \\'%\", \"mountain\", \"%\\'AND Char_Count <\",300))\n  \n  return(output)\n  output\n}\n\n\n#' @param category A string representing the category. \n#' @parm char_count An optional integer input parameter representing the max character count. If not included, the default is set at 300. \n#' @return A JSON of every quote in that category, with quote, author, category, character count. \n#* @get /category\nquote_category <- function(category, char_count = 300) {\n  #clean input \n  library(magrittr)\n  library(stringr)\n  category <- category %>% str_to_lower() %>% str_trim()\n  \n  #connect to database\n  library(RSQLite)\n  db <- dbConnect(SQLite(), \"Auto_Generation.db\")\n  \n  #verify connection\n  if (dbIsValid(db) & dbExistsTable(db, \"Content\")) {\n    \n    #query table for input category\n    content <- dbGetQuery(db, paste(\"SELECT * FROM Content WHERE Category == \\'\",category,\"\\' AND Char_Count <\",char_count, \";\", sep = \"\"))\n    \n    if (nrow(content) == 0) {\n      warning(\"There was not any content in that category.\")\n    }\n    \n    #convert to JSON \n    library(jsonlite)\n    output <- toJSON(content)\n  } else {\n    stop(\"Error connecting to the database.\")\n  }\n  \n  return(output)\n}\n\n\n\n#' @param image_url A string representing the URL of the image to be interpreted. Must begin with 'https://'.\n#' @parm char_count An optional integer input parameter representing the max character count. If not included, the default is set at 300. \n#' @return A JSON of every quote related to that image, with quote, author, category, character count.\n#* @get /imagerec\nquote_imagerec <- function(image_url, char_count = 300) {\n  #generate image recognition tags for input\n  image_tags <- tag_image(image_url)\n  \n  #connect to database\n  library(RSQLite)\n  db <- dbConnect(SQLite(), \"Auto_Generation.db\")\n  \n  #verify connection\n  if (dbIsValid(db) & dbExistsTable(db, \"Content\")) {\n    \n    #search content for top 5 tags \n    content <- data.frame(\"row_names\" = character(0), \"ID\" = integer(0), \"Text\" = character(0), \"Author\" = character(0), \"Category\"= character(0), \"Char_Count\" = integer(0))\n    \n    for (i in image_tags$Tag[1:5]) {\n      content <- rbind(content, dbGetQuery(db, paste(\"SELECT * FROM Content WHERE Text LIKE \\'%\", i, \"%\\'AND Char_Count <\",char_count, \";\", sep =\"\")))\n      content <- rbind(content, dbGetQuery(db, paste(\"SELECT * FROM Content WHERE Category LIKE \\'%\", i, \"%\\'AND Char_Count <\",char_count, \";\", sep =\"\")))\n    }\n    if (nrow(content) == 0) {\n      warning(\"There is no content matching this image's top 5 tags.\")\n    }\n    \n    #convert to JSON \n    library(jsonlite)\n    output <- toJSON(content)\n    \n  } else {\n    \n    stop(\"Error connecting to the database.\")\n    \n  }\n  \n  return(output)\n}\n\n\n\n\n#' @param url A string representing the URL of the image to be interpreted. Must begin with 'http(s)://'.\n#' @return A dataframe of tags and confidence based on image recognition performed on the image passed in with the input url.\ntag_image <- function(url) {\n  \n  #load package\n  library(httr)\n  \n  #store auth keys\n  api_key <- \"acc_d4e484d32c6754e\"\n  api_secret <- \"39331edd5fafb67536beacda2e8f81a2\"\n  \n  #build url with api endpoint\n  comb_url <- paste(\"https://api.imagga.com/v1/tagging?url=\", url, sep = \"\")\n  \n  #get request to immaga api \n  imagga_resp = GET(comb_url, authenticate(api_key, api_secret))\n  \n  #if get request is successful:\n  if(http_status(imagga_resp)$category == \"Success\") {\n    \n    #get/parse response content \n    resp_content <- content(imagga_resp, as = \"parsed\")\n    \n    #error checking\n    if (!is.null(resp_content$unsuccessful)) {\n      stop(\"The input URL does not correspond to a downloadable image.\")\n    }\n    \n    #get only results from content\n    results <- resp_content$results\n    \n    #get tags as list from results\n    tags <- results[[1]]$tags\n    \n    #unlist tags to vector\n    unlistTags <- unlist(tags)\n    \n    #index vector properly to build dataframe\n    tagIndex <- seq(from = 2, to = length(unlistTags), by = 2)\n    \n    #seperate tags and confidence scores \n    tags <- unlistTags[tagIndex] %>% as.character()\n    confidence <- unlistTags[-tagIndex] %>% as.character() %>% as.numeric()\n    \n    #build dataframe fom results\n    df <- data.frame(\"Tag\" = tags, \"Confidence\" = confidence)\n    df$Tag <- as.character(df$Tag)\n    df$Confidence <- as.numeric(as.character(df$Confidence))\n    \n    #return data frame with tags + confidences\n    return(df)\n  }\n  \n  #if get request is unsuccessful\n  else {\n    stop(\"Error processing image.\")\n  }\n  \n}\n\n\n#' Adds input content to the filtered and categorized database.\n#* @post /addmanual \nadd_quote_manual <- function(text, category = \"\", author = \"\") {\n  #connect to database\n  library(RSQLite)\n  db <- dbConnect(SQLite(), \"Auto_Generation.db\")\n  \n  #verify connection\n  if (dbIsValid(db) & dbExistsTable(db, \"Content\")) {\n    \n    continue <- TRUE\n    \n    while(continue == TRUE) {\n      \n      #calculate character count of text \n      char_count <- nchar(text)\n      \n      #calculate index - adds 1 to the index of the last element in the table\n      previous <- (dbGetQuery(db, \"SELECT ID FROM Content WHERE ID = (SELECT MAX(ID) FROM Content)\"))[1,1]\n      index <- previous + 1\n      \n      #clean inputs\n      library(magrittr)\n      library(stringr)\n      text <- str_trim(text)\n      author <- str_trim(author)\n      category <- category %>% str_to_lower() %>% str_trim()\n      \n      #add escape characters for single quotes\n      text <- gsub(\"\\'\", \"\\\\'\", text)\n      \n      #add to database\n      dbGetQuery(db, paste(\"INSERT INTO Content VALUES(\",index,\",\\\"\",\n                           text, \"\\\", \\\"\",\n                           author, \"\\\", \\'\",\n                           category, \"\\', \", \n                           char_count,\");\", sep = \"\"))\n      \n      #ask if user wants to continue inputting quotes\n      print(\"Would you like to continue inputting quotes? (y or n) : \")\n      repeat {\n        continue <- readline() %>% str_to_lower() %>% str_trim()\n        \n        if (continue == \"y\") {\n          continue <- TRUE\n        } else if (continue == 'n'| continue ==\"\") {\n          continue <- FALSE\n        } else {\n          print(\"Invalid input. Input y to continue adding quotes. To end the function, input n or press ENTER.\")\n        }\n        \n        if (continue == TRUE | continue == FALSE) \n          break\n      }\n      \n      #get next piece of content \n      if (continue == TRUE) {\n        print(\"Enter the text of the content: \")\n        text <- readline()\n        \n        print(\"Enter the author of the content (If none, press ENTER)\")\n        author <- readline()\n        \n        print(\"Enter the category (If none, press ENTER)\")\n        category <- readline()\n      }\n    }\n  } else {\n    stop(\"Error connecting to the database.\")\n  }\n}\n\n\n#' @param ID An int vector representing the ID numbers of the rows you want to remove.\n#* @post /removerow\nremove_row <- function(ID) {\n  #connect to database\n  library(RSQLite)\n  db <- dbConnect(SQLite(), \"Auto_Generation.db\")\n  \n  #verify connection\n  if (dbIsValid(db) & dbExistsTable(db, \"Content\")) {\n    \n    #remove rows\n    for (i in ID) {\n      dbGetQuery(db, paste(\"DELETE FROM Content WHERE id = \", i, sep = \"\"))\n    }\n    \n  }\n}\n\n\n\n#' @param ID An int representing the ID number of the row you want to edit.\n#' @param field A string representing the field to be edited \n#' @param edit A string representing the new text to be input into the table \n#' @details Valid fields that can be edited are : Text, Author, and Category. ID and char_count can not be edited. If text is edited, char_count is automatically updated. \n#* @post /editrow\nedit_row <- function(ID, field, edit) {\n  \n  #clean inputs \n  library(magrittr)\n  library(stringr)\n  field <- field %>% str_to_title() %>% str_trim()\n  \n  #don't let user edit ID or char_count \n  if (field == \"Id\" | field == \"Char_count\") {\n    stop(\"You cannot edit the ID or char_count fields.\")\n  }\n  \n  #connect to database\n  library(RSQLite)\n  db <- dbConnect(SQLite(), \"Auto_Generation.db\")\n  \n  #verify connection\n  if (dbIsValid(db) & dbExistsTable(db, \"Content\")) {\n    \n    #save field to be updated \n    old <- (dbGetQuery(db, paste(\"SELECT \", field, \" FROM Content WHERE ID = \", ID, sep = \"\")))[1,1]\n    \n    #edit field \n    dbGetQuery(db, paste(\"UPDATE Content SET \", field, \" = '\", edit, \"' WHERE ID = \", ID, sep = \"\"))\n    \n    #recalculate char_count if text was edited \n    if (field == \"Text\") {\n      char_count <- nchar(edit)\n      dbGetQuery(db, paste(\"UPDATE Content SET Char_count = \", char_count, \" WHERE ID = \", ID, sep = \"\"))\n    }\n  }\n  \n  print(paste(\"You replaced the \", field, \" \", old, \" with \",edit, \".\", sep = \"\"))\n}",
    "created" : 1471428834539.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "198391990",
    "id" : "A0931348",
    "lastKnownWriteTime" : 1471429520,
    "last_content_update" : 1471429520107,
    "path" : "C:/Users/maggie.lou/Dropbox/MyDocuments/NU 2019/Data Mining/Projects/Over/Quote_Generation/quote_generation.R",
    "project_path" : "quote_generation.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}